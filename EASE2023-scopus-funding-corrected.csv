ABSTRACT,AUTHORKEYWORDS,AUTHORS,BOOKTITLE,DOI,FUNDINGDETAILS,FUNDINGDETAILSCOUNTRY,FUNDINGTEXT,KEYWORDS,NOTE,TITLE,VENUE,YEAR,SOURCE,TYPE
"Repairing design models is a laborious task that requires a considerable amount of time and effort from developers. Repair recommendation (RR) approaches focus on reducing the effort and improving the quality of the repairs performed. Such approaches have been evaluated in terms of scalability, correctness, and minimalism. These evaluations, however, have not investigated how developers can benefit from using RRs and how they perceive the difficulty of applying RRs. Investigating and discussing the use of RRs from the developers' perspective is important to demonstrate the benefits of applying such approaches in practice. We explore this opportunity by conducting a controlled experiment carried out with 24 developers where they repaired UML design models in eight different tasks, with and without RRs. The findings indicate that developers can benefit from RRs in complex tasks by improving their effectiveness and efficiency. The results also evidence that the use of RRs does not impact the developers' perceived difficulty and confidence when repairing models. Furthermore, our findings show that not all developers choose the same RR, but rather, have varied preferences. Thus, the provision of RRs leads to developers considering additional alternatives to repair an inconsistency. © 2023 ACM.",Consistency Checking;  Controlled Experiment;  Repair Recommendations,"Marchezan, L. and Assuncao, W.K.G. and Michelon, G.K. and Egyed, A.",,10.1145/3593434.3593482,Austrian Science Fund,Austria,"This research has been funded by the Austrian Science Fund (FWF, P31989-N31), by the FFG-COMET-K1 Center “Pro2Future”, (881844), and by the LIT Secure and Correct System Lab funded by the State of Upper Austria.","Repair, Complex task;  Consistency checking;  Controlled experiment;  Design models;  Effectiveness and efficiencies;  Perceived difficulties;  Repair recommendation;  UML design, Software engineering",cited By 0,Do Developers Benefit from Recommendations when Repairing Inconsistent Design Models? a Controlled Experiment,ACM International Conference Proceeding Series,2023,EASE,conf
"Technical debt is often the result of Short Run decisions made during code development, which can lead to long-term maintenance costs and risks. Hence, evaluating the progression of a project and understanding related code quality aspects is essential. Fortunately, the prioritization process for addressing technical debt can be expedited with code analysis tools like the established SonarQube. Unfortunately, we experienced some limitations with this tool and have had some requirements from the industry that were not yet addressed. Through this experience report and the analysis of scientific papers, this work contributes: (1) a reassessment of technical debt within the industry, (2) considers the benefits of employing SonarQube as well as its limitations when evaluating and prioritizing technical debt, (3) introduces a novel tool named SoHist which addresses these limitations and offers additional features for the assessment and prioritization of technical debt, and (4) exemplifies the usage of this tool in two industrial settings in the ITEA3 SmartDelta project. © 2023 Owner/Author.",software quality evolution;  SoHist;  SonarQube;  technical debt,"Dornauer, B. and Felderer, M. and Weinzerl, J. and Racasan, M.-C. and Hess, M.",,10.1145/3593434.3593460,Bundesministerium fuer Bildung und Forschung,Germany,,"Quality control, Code analysis;  Code development;  Long-term maintenances;  Maintenance cost;  Short runs;  Software Quality;  Software quality evolution;  Sohist;  Sonarqube;  Technical debts, Computer software selection and evaluation",cited By 1,SoHist: A Tool for Managing Technical Debt through Retro Perspective Code Analysis,ACM International Conference Proceeding Series,2023,EASE,conf
"CONTEXT: Self-efficacy is a concept researched in various areas of knowledge that impacts various factors such as performance, satisfaction, and motivation. In Software Engineering, it has mainly been studied in the academic context, presenting results similar to other areas of knowledge. However, it is also important to understand its impact in the industrial context. OBJECTIVE: Therefore, this study aims to understand the impact on the software development context with a focus on understanding the behavioral signs of self-efficacy in software engineers and how self-efficacy can impact the work-day of software engineers. METHOD: A qualitative research was conducted using semi-structured questionnaires with 31 interviewees from a software development company located in Brazil. The interviewees participated in a Bootcamp and were later assigned to software development teams. Thematic analysis was used to analyze the data. RESULTS: In the perception of the interviewees, 21 signs were found that are related to people with high and low self-efficacy. These signs were divided into two dimensions: social and cognitive. Also, 18 situations were found that can lead to an increase or decrease of self-efficacy of software engineers. Finally, 12 factors were mentioned that can impact software development teams. CONCLUSION: This work evidences a set of behavioral signs that can help team leaders to better perceive the self-efficacy of their members. It also presents a set of situations that both leaders and individuals can use to improve their self-efficacy in the development context, and finally, factors that can be impacted by self-efficacy in the software development context are also presented. Finally, this work emphasizes the importance of understanding self-efficacy in the industrial context. © 2023 ACM.",,"Ribeiro, D. and Lima, R. and Franca, C. and Souza, A. and Silva, I. and Pinto, G.",,10.1145/3593434.3593467,Conselho Nacional de Desenvolvimento Cientifico e Tecnologico,Brazil,,"Engineering research;  Software design, Engineering industries;  Industrial context;  Interview study;  Performance;  Qualitative research;  Self efficacy;  Semi-structured;  Software development teams;  Thematic analysis;  Two-dimensions, Engineers",cited By 0,Understanding Self-Efficacy in Software Engineering Industry: An Interview study,ACM International Conference Proceeding Series,2023,EASE,conf
"Mobile app development frameworks lower the effort to write and deploy apps across different execution platforms. At the same time, their use may limit native optimizations and impose overhead, increasing resource usage. In this paper, we analyze the resource usage of Android benchmarks and apps based on three mobile app development frameworks, Flutter, React Native, and Ionic, comparing them to functionally equivalent, native variants written in Java. These frameworks, besides being in widespread use, represent three different approaches for developing multiplatform apps: Flutter supports the deployment of apps that are compiled and run fully natively, React Native runs interpreted JavaScript code combined with native views for different platforms, and Ionic is based on web apps, which means that it does not depend on platform-specific details. We measure the energy consumption, execution time, and memory usage of ten optimized, CPU-intensive benchmarks, to gauge overhead in a controlled manner, and two applications, to measure their impact when running commonly mobile app functionalities. Our results show that cross-platform and hybrid frameworks can be competitive in CPU-intensive applications. In five of the ten benchmarks, at least one framework-based version exhibits lower energy consumption and execution time than its native counterpart, up to a reduction of 81% in energy and 83% in execution time. Furthermore, in three other benchmarks, framework-based and native versions achieved similar results. Overall, Flutter, usually imposes the least overhead in execution time and energy, while React Native imposes the highest in all the benchmarks. However, in an app that continuously animates multiple images on the screen, without interaction, the React Native version uses the least CPU and energy, up to a reduction of 96% in energy compared to the second-best framework-based version. These findings highlight the importance of analyzing expected application behavior before committing to a specific framework. © 2023 ACM.",,"Oliveira, W. and Moraes, B. and Castor, F. and Fernandes, J.P.",,10.1145/3593434.3593487,Conselho Nacional de Desenvolvimento Cientifico e Tecnologico,Brazil,,"Benchmarking;  Flutter (aerodynamics), % reductions;  CPU-intensive;  Development frameworks;  Energy;  Execution platforms;  Javascript;  Mobile app;  Multi-platform;  Optimisations;  Resource usage, Energy utilization",cited By 1,Analyzing the Resource Usage Overhead of Mobile App Development Frameworks,ACM International Conference Proceeding Series,2023,EASE,conf
"This research explores the challenges in agile contract modeling for software innovation projects, particularly for outsourced projects. Literature has presented various methods and frameworks for agile contract management, but there is still a gap in effectively establishing the best contract approach for each project based on specific conditions. This work aims to contribute with a framework definition that effectively applies practical approaches for contract deployment suitable for software innovation projects, considering the best contractual practices related to projects specific context. The study will conduct an action research at CESAR, a prominent Brazilian Institute of Science and Technology (ICT) with 1200 employees and 26 years old, to establish effective agile contract models and its implementation that better support agile management and project success. The study hopes to contribute to understanding the relationship between the type of contract and project outcomes and to provide better agile contract implementation for software innovation projects developed by outsourced companies. © 2023 ACM.",Agile contracts;  Agile project management;  Pricing and contract design;  Software project management,"Gomes, A.",,10.1145/3593434.3593473,Conselho Nacional de Desenvolvimento Cientifico e Tecnologico,Brazil,,"Human resource management;  Project management;  Software engineering, Agile contract;  Agile project management;  Contract design;  Contract management;  Innovation programs;  Outsourced projects;  Pricing and contract design;  Project-based;  Software innovations;  Software project management, Costs",cited By 0,Effective Agile Contracts Framework for Software Innovation Projects,ACM International Conference Proceeding Series,2023,EASE,conf
"This research explores the challenges in agile contract modeling for software innovation projects, particularly for outsourced projects. Literature has presented various methods and frameworks for agile contract management, but there is still a gap in effectively establishing the best contract approach for each project based on specific conditions. This work aims to contribute with a framework definition that effectively applies practical approaches for contract deployment suitable for software innovation projects, considering the best contractual practices related to projects specific context. The study will conduct an action research at CESAR, a prominent Brazilian Institute of Science and Technology (ICT) with 1200 employees and 26 years old, to establish effective agile contract models and its implementation that better support agile management and project success. The study hopes to contribute to understanding the relationship between the type of contract and project outcomes and to provide better agile contract implementation for software innovation projects developed by outsourced companies. © 2023 ACM.",Agile contracts;  Agile project management;  Pricing and contract design;  Software project management,"Gomes, A.",,10.1145/3593434.3593473,Coordenacao de Aperfeicoamento de Pessoal de Nivel Superior,Brazil,"This work is partially supported by INES 2.0 (www.ines.org.br), CNPq grant 465614/2014-0, FACEPE grants APQ-0399-1.03/17 and APQ/0388-1.03/14, CAPES grant 88887.136410/2017-00.","Human resource management;  Project management;  Software engineering, Agile contract;  Agile project management;  Contract design;  Contract management;  Innovation programs;  Outsourced projects;  Pricing and contract design;  Project-based;  Software innovations;  Software project management, Costs",cited By 0,Effective Agile Contracts Framework for Software Innovation Projects,ACM International Conference Proceeding Series,2023,EASE,conf
"Since internet applications have reached a satisfactory level of maturity, large information systems have been developed to manage and facilitate access to documents. Simultaneously, there was an enormous international effort to digitise documents, enabling access via the internet. This endeavour facilitated the access of researchers to extensive document repositories and libraries, while also aiding companies in organising their documents. Two decades later, these vast databases are reasonably clean and well-organised, although the software used to manage and feed them is gradually becoming obsolete. Therefore, it is imperative to continuously reengineer the software to maintain optimal functionality. Furthermore, after the initial effort to digitise documents and create the initial metadata, it is reasonable to augment the metadata information pertaining to the documents. As such, two necessities are apparent: improving support for reengineering legacy document information systems and enabling data model updates and schema evolution to accommodate new information. Our goal is to automate the reengineering process as a whole. © 2023 ACM.",automated development;  document information systems;  schema evolution;  software reengineering,"Ramos-Vidal, D.",,10.1145/3593434.3593436,European Commission,EU,,"Information management;  Information systems;  Information use;  Legacy systems;  Metadata, Automated development;  Document information systems;  Document repositories;  Internet application;  Legacy documents;  Metadata information;  Model updates;  Schema evolution;  Software reengineering, Reengineering",cited By 0,Reengineering legacy document information systems: Challenges and solutions,ACM International Conference Proceeding Series,2023,EASE,conf
"Architectural smells have been studied in the literature looking at several aspects, such as their impact on maintainability as a source of architectural debt, their correlations with code smells, and their evolution in the history of complex projects. The goal of this paper is to extend the study of architectural smells from a different perspective. We focus our attention on software performance, and we aim to quantify the impact of architectural smells as support to explain the root causes of system performance hindrances. Our method consists of a study design matching the occurrence of architectural smells with performance metrics. We exploit state-of-the-art tools for architectural smell detection, software performance profiling, and testing the systems under analysis. The removal of architectural smells generates new versions of systems from which we derive some observations on design changes improving/worsening performance metrics. Our experimentation considers two complex open-source projects, and results show that the detection and removal of two common types of architectural smells yield lower response time (up to ) with a large effect size, i.e., for - of the hotspot methods. The median memory consumption is also lower (up to ) with a large effect size for all the services. © 2023 ACM.",Architectural Smells;  Software Architecture;  Software Performance,"Arcelli Fontana, F. and Camilli, M. and Rendina, D. and Taraboi, A.G. and Trubiani, C.",,10.1145/3593434.3593442,European Commission,EU,"We thank the anonymous reviewers for their valuable feedback. We acknowledge the support of MUR PRIN project 2017TWRCNB SEDUCE, and the PNRR MUR project VITALITY (ECS00000041) Spoke 2 ASTRA - Advanced Space Technologies and Research Alliance.","Odors;  Open source software, Architectural smell;  Code smell;  Complex programs;  Effect size;  Exploratory studies;  Performance metrices;  Root cause;  Software performance;  Study design;  Systems performance, Software testing",cited By 0,Impact of Architectural Smells on Software Performance: An Exploratory Study,ACM International Conference Proceeding Series,2023,EASE,conf
"Context. WebAssembly (WASM) is a low-level bytecode format that is gaining traction among Internet of Things (IoT) devices. Because of IoT devices' resources limitations, using WASM is becoming a popular technique for virtualization on IoT devices. However, it is unclear if the promises of WASM regarding its efficient use of energy and performance gains hold true. Goal. This study aims to determine how different source programming languages and runtime environments affect the energy consumption and performance of WASM binaries. Method. We perform a controlled experiment where we compile three benchmarking algorithms from four different programming languages (i.e., C, Rust, Go, and JavaScript) to WASM and run them using two different WASM runtimes on a Raspberry Pi 3B. Results. The source programming language significantly influences the performance and energy consumption of WASM binaries. We did not find evidence of the impact of the runtime environment. However, certain combinations of source programming language and runtime environment leads to a significant improvement of its energy consumption and performance. Conclusions. IoT developers should choose the source programming language wisely to benefit from better performance and a reduction in energy consumption. Specifically, Javy-compiled JavaScript should be avoided, while C and Rust are better options. We found no conclusive results for the choice of the WASM runtime. © 2023 ACM.",,"Wagner, L. and Mayer, M. and Marino, A. and Soldani Nezhad, A. and Zwaan, H. and Malavolta, I.",,10.1145/3593434.3593454,European Commission,EU,This project is partially supported by (i) the European Union’s Horizon 2020 research and innovation programme under the Marie Sklodowska-Curie grant agreement No 871342 “uDEVOPS” and (ii) the Individual Travel Grant of the Amsterdam University Fund.,"C (programming language);  Internet of things, Bytecodes;  Device resources;  Energy performance;  Energy-consumption;  Javascript;  Language environment;  Performance;  Resource limitations;  Runtime environments;  Runtimes, Energy utilization",cited By 0,On the Energy Consumption and Performance of WebAssembly Binaries across Programming Languages and Runtimes in IoT,ACM International Conference Proceeding Series,2023,EASE,conf
"Mobile app development frameworks lower the effort to write and deploy apps across different execution platforms. At the same time, their use may limit native optimizations and impose overhead, increasing resource usage. In this paper, we analyze the resource usage of Android benchmarks and apps based on three mobile app development frameworks, Flutter, React Native, and Ionic, comparing them to functionally equivalent, native variants written in Java. These frameworks, besides being in widespread use, represent three different approaches for developing multiplatform apps: Flutter supports the deployment of apps that are compiled and run fully natively, React Native runs interpreted JavaScript code combined with native views for different platforms, and Ionic is based on web apps, which means that it does not depend on platform-specific details. We measure the energy consumption, execution time, and memory usage of ten optimized, CPU-intensive benchmarks, to gauge overhead in a controlled manner, and two applications, to measure their impact when running commonly mobile app functionalities. Our results show that cross-platform and hybrid frameworks can be competitive in CPU-intensive applications. In five of the ten benchmarks, at least one framework-based version exhibits lower energy consumption and execution time than its native counterpart, up to a reduction of 81% in energy and 83% in execution time. Furthermore, in three other benchmarks, framework-based and native versions achieved similar results. Overall, Flutter, usually imposes the least overhead in execution time and energy, while React Native imposes the highest in all the benchmarks. However, in an app that continuously animates multiple images on the screen, without interaction, the React Native version uses the least CPU and energy, up to a reduction of 96% in energy compared to the second-best framework-based version. These findings highlight the importance of analyzing expected application behavior before committing to a specific framework. © 2023 ACM.",,"Oliveira, W. and Moraes, B. and Castor, F. and Fernandes, J.P.",,10.1145/3593434.3593487,European Regional Development Fund,EU,,"Benchmarking;  Flutter (aerodynamics), % reductions;  CPU-intensive;  Development frameworks;  Energy;  Execution platforms;  Javascript;  Mobile app;  Multi-platform;  Optimisations;  Resource usage, Energy utilization",cited By 1,Analyzing the Resource Usage Overhead of Mobile App Development Frameworks,ACM International Conference Proceeding Series,2023,EASE,conf
"We propose a solution combining source code static analysis with searchable symmetric encryption to detect input validation vulnerabilities of web applications in encrypted PHP code, allowing developers to protect their codebase from malicious third parties while simultaneously discovering vulnerabilities in it. Results show that our solution is capable of identifying vulnerabilities with precision similar to traditional static code, non-privacy-preserving analysers and exhibits a maximum overhead increase of around 16,55%. © 2023 Owner/Author.",,"Martins, J. and Medeiros, I. and Ferreira, B.",,10.1145/3593434.3593483,European Regional Development Fund,EU,"This work was supported by FCT through the project SEAL (PTDC/CCI-INF/29058/2017) and the LASIGE research unit (UIDB/00408/2020 and UIDP /00408/2020), and by P2020 through project XIVT (I3C4-17039/FEDER-039238).","Codes (symbols);  Privacy-preserving techniques, Input validation;  Privacy preserving;  Source code static analysis;  Static codes;  Symmetric encryption;  Third parties;  WEB application;  Web applications, Static analysis",cited By 0,Code Privacy in Detection of Web Vulnerabilities,ACM International Conference Proceeding Series,2023,EASE,conf
"Background: Adaptive user interfaces have the advantage of being able to dynamically change their aspect and/or behaviour depending on the characteristics of the context of use, i.e. To improve user experience. User experience is an important quality factor that has been primarily evaluated with classical measures (e.g. effectiveness, efficiency, satisfaction), but to a lesser extent with physiological measures, such as emotion recognition, skin response, or brain activity. Aim: In a previous exploratory experiment involving users with different profiles and a wide range of ages, we analysed user experience in terms of cognitive load, engagement, attraction and memorisation when employing twenty graphical adaptive menus through the use of an Electroencephalogram (EEG) device. The results indicated that there were statistically significant differences for these four variables. However, we considered that it was necessary to confirm or reject these findings using a more homogeneous group of users. Method: We conducted an operational internal replication study with 40 participants. We also investigated the potential correlation between EEG signals and the participants' user experience ratings, such as their preferences. Results: The results of this experiment confirm that there are statistically significant differences between the EEG variables when the participants interact with the different adaptive menus. Moreover, there is a high correlation among the participants' user experience ratings and the EEG signals, and a trend regarding performance has emerged from our analysis. Conclusions: These findings suggest that EEG signals could be used to evaluate user experience. With regard to the menus studied, our results suggest that graphical menus with different structures and font types produce more differences in users' brain responses, while menus which use colours produce more similarities in users' brain responses. Several insights with which to improve users' experience of graphical adaptive menus are outlined. © 2023 ACM.",Adaptive Systems;  EEG;  Experiment;  User Interfaces;  UX,"Gaspar-Figueiredo, D. and Abrahao, S. and Insfran, E. and Vanderdonckt, J.",,10.1145/3593434.3593452,European Social Fund,EU,This work was supported by the AKILA project (CIAICO/2021/303) funded by the GVA and the European Union through the Operational Program of the European Social Fund (ESF). D. Gaspar-Figueiredo is recipient of a Predoctoral Research staff-training program (GVA ACIF/2021/172) funded by the GVA.,"Brain;  Electrophysiology;  Emotion Recognition;  Physiological models;  Quality control;  User interfaces, Adaptive user interface;  Brain response;  Context of use;  Electroencephalogram signals;  Emotion recognition;  Physiological measures;  Quality factors;  Replication study;  Statistically significant difference;  Users' experiences, Electroencephalography",cited By 0,Measuring User Experience of Adaptive User Interfaces using EEG: A Replication Study,ACM International Conference Proceeding Series,2023,EASE,conf
"CONTEXT: Self-efficacy is a concept researched in various areas of knowledge that impacts various factors such as performance, satisfaction, and motivation. In Software Engineering, it has mainly been studied in the academic context, presenting results similar to other areas of knowledge. However, it is also important to understand its impact in the industrial context. OBJECTIVE: Therefore, this study aims to understand the impact on the software development context with a focus on understanding the behavioral signs of self-efficacy in software engineers and how self-efficacy can impact the work-day of software engineers. METHOD: A qualitative research was conducted using semi-structured questionnaires with 31 interviewees from a software development company located in Brazil. The interviewees participated in a Bootcamp and were later assigned to software development teams. Thematic analysis was used to analyze the data. RESULTS: In the perception of the interviewees, 21 signs were found that are related to people with high and low self-efficacy. These signs were divided into two dimensions: social and cognitive. Also, 18 situations were found that can lead to an increase or decrease of self-efficacy of software engineers. Finally, 12 factors were mentioned that can impact software development teams. CONCLUSION: This work evidences a set of behavioral signs that can help team leaders to better perceive the self-efficacy of their members. It also presents a set of situations that both leaders and individuals can use to improve their self-efficacy in the development context, and finally, factors that can be impacted by self-efficacy in the software development context are also presented. Finally, this work emphasizes the importance of understanding self-efficacy in the industrial context. © 2023 ACM.",,"Ribeiro, D. and Lima, R. and Franca, C. and Souza, A. and Silva, I. and Pinto, G.",,10.1145/3593434.3593467,Fundacao Amazonia Paraense de Amparo a Pesquisa,Brazil,We thank all the practitioners who participate in our study. We thank the Zup innovation to support our work. We also thank the reviewers for their helpful comments. This work was partially supported by CNPq (#309032/2019-9) and FAPESPA (#053/2021).,"Engineering research;  Software design, Engineering industries;  Industrial context;  Interview study;  Performance;  Qualitative research;  Self efficacy;  Semi-structured;  Software development teams;  Thematic analysis;  Two-dimensions, Engineers",cited By 0,Understanding Self-Efficacy in Software Engineering Industry: An Interview study,ACM International Conference Proceeding Series,2023,EASE,conf
"Mobile app development frameworks lower the effort to write and deploy apps across different execution platforms. At the same time, their use may limit native optimizations and impose overhead, increasing resource usage. In this paper, we analyze the resource usage of Android benchmarks and apps based on three mobile app development frameworks, Flutter, React Native, and Ionic, comparing them to functionally equivalent, native variants written in Java. These frameworks, besides being in widespread use, represent three different approaches for developing multiplatform apps: Flutter supports the deployment of apps that are compiled and run fully natively, React Native runs interpreted JavaScript code combined with native views for different platforms, and Ionic is based on web apps, which means that it does not depend on platform-specific details. We measure the energy consumption, execution time, and memory usage of ten optimized, CPU-intensive benchmarks, to gauge overhead in a controlled manner, and two applications, to measure their impact when running commonly mobile app functionalities. Our results show that cross-platform and hybrid frameworks can be competitive in CPU-intensive applications. In five of the ten benchmarks, at least one framework-based version exhibits lower energy consumption and execution time than its native counterpart, up to a reduction of 81% in energy and 83% in execution time. Furthermore, in three other benchmarks, framework-based and native versions achieved similar results. Overall, Flutter, usually imposes the least overhead in execution time and energy, while React Native imposes the highest in all the benchmarks. However, in an app that continuously animates multiple images on the screen, without interaction, the React Native version uses the least CPU and energy, up to a reduction of 96% in energy compared to the second-best framework-based version. These findings highlight the importance of analyzing expected application behavior before committing to a specific framework. © 2023 ACM.",,"Oliveira, W. and Moraes, B. and Castor, F. and Fernandes, J.P.",,10.1145/3593434.3593487,Fundacao de Amparo a Ciencia e Tecnologia do Estado de Pernambuco,Brazil,,"Benchmarking;  Flutter (aerodynamics), % reductions;  CPU-intensive;  Development frameworks;  Energy;  Execution platforms;  Javascript;  Mobile app;  Multi-platform;  Optimisations;  Resource usage, Energy utilization",cited By 1,Analyzing the Resource Usage Overhead of Mobile App Development Frameworks,ACM International Conference Proceeding Series,2023,EASE,conf
"This research explores the challenges in agile contract modeling for software innovation projects, particularly for outsourced projects. Literature has presented various methods and frameworks for agile contract management, but there is still a gap in effectively establishing the best contract approach for each project based on specific conditions. This work aims to contribute with a framework definition that effectively applies practical approaches for contract deployment suitable for software innovation projects, considering the best contractual practices related to projects specific context. The study will conduct an action research at CESAR, a prominent Brazilian Institute of Science and Technology (ICT) with 1200 employees and 26 years old, to establish effective agile contract models and its implementation that better support agile management and project success. The study hopes to contribute to understanding the relationship between the type of contract and project outcomes and to provide better agile contract implementation for software innovation projects developed by outsourced companies. © 2023 ACM.",Agile contracts;  Agile project management;  Pricing and contract design;  Software project management,"Gomes, A.",,10.1145/3593434.3593473,Fundacao de Amparo a Ciencia e Tecnologia do Estado de Pernambuco,Brazil,,"Human resource management;  Project management;  Software engineering, Agile contract;  Agile project management;  Contract design;  Contract management;  Innovation programs;  Outsourced projects;  Pricing and contract design;  Project-based;  Software innovations;  Software project management, Costs",cited By 0,Effective Agile Contracts Framework for Software Innovation Projects,ACM International Conference Proceeding Series,2023,EASE,conf
"CONTEXT: Self-efficacy is a concept researched in various areas of knowledge that impacts various factors such as performance, satisfaction, and motivation. In Software Engineering, it has mainly been studied in the academic context, presenting results similar to other areas of knowledge. However, it is also important to understand its impact in the industrial context. OBJECTIVE: Therefore, this study aims to understand the impact on the software development context with a focus on understanding the behavioral signs of self-efficacy in software engineers and how self-efficacy can impact the work-day of software engineers. METHOD: A qualitative research was conducted using semi-structured questionnaires with 31 interviewees from a software development company located in Brazil. The interviewees participated in a Bootcamp and were later assigned to software development teams. Thematic analysis was used to analyze the data. RESULTS: In the perception of the interviewees, 21 signs were found that are related to people with high and low self-efficacy. These signs were divided into two dimensions: social and cognitive. Also, 18 situations were found that can lead to an increase or decrease of self-efficacy of software engineers. Finally, 12 factors were mentioned that can impact software development teams. CONCLUSION: This work evidences a set of behavioral signs that can help team leaders to better perceive the self-efficacy of their members. It also presents a set of situations that both leaders and individuals can use to improve their self-efficacy in the development context, and finally, factors that can be impacted by self-efficacy in the software development context are also presented. Finally, this work emphasizes the importance of understanding self-efficacy in the industrial context. © 2023 ACM.",,"Ribeiro, D. and Lima, R. and Franca, C. and Souza, A. and Silva, I. and Pinto, G.",,10.1145/3593434.3593467,Fundacao de Amparo a Pesquisa do Estado de Sao Paulo,Brazil,,"Engineering research;  Software design, Engineering industries;  Industrial context;  Interview study;  Performance;  Qualitative research;  Self efficacy;  Semi-structured;  Software development teams;  Thematic analysis;  Two-dimensions, Engineers",cited By 0,Understanding Self-Efficacy in Software Engineering Industry: An Interview study,ACM International Conference Proceeding Series,2023,EASE,conf
"Software engineering artifacts are central to DevOps, enabling the collaboration of teams involved with integrating the development and operations domains. However, collaboration around DevOps artifacts has yet to receive detailed research attention. We apply the sociological concept of Boundary Objects to describe and evaluate the specific software engineering artifacts that enable a cross-disciplinary understanding. Using this focus, we investigate how different DevOps stakeholders can collaborate efficiently using common artifacts. We performed a multiple case study and conducted twelve semi-structured interviews with DevOps practitioners in nine companies. We elicited participants' collaboration practices, focusing on the coordination of stakeholders and the use of engineering artifacts as a means of translation. This paper presents a consolidated overview of four categories of DevOps Boundary Objects and eleven stakeholder groups relevant to DevOps. To help practitioners assess cross-disciplinary knowledge management strategies, we detail how DevOps Boundary Objects contribute to four areas of DevOps knowledge and propose derived dimensions to evaluate their use. © 2023 Owner/Author.",Agile Software Development;  Boundary Objects;  DevOps;  Knowledge Management;  Software Engineering Artifacts,"Matthies, C. and Heinrich, R. and Wohlrab, R.",,10.1145/3593434.3593441,Helmholtz-Gemeinschaft,Germany,"We thank all interviewees for their time and valuable responses. This work was partially supported by the Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by the Knut and Alice Wallenberg Foundation, the topic Engineering Secure Systems (46.23.03) of the Helmholtz Association (HGF) and KASTEL Security Research Labs. We thank the GoTo Technologies Germany GmbH and the SPEC Research Group for their valuable support.","Software design, Agile software development;  Boundary objects;  Collaboration practices;  Common artefacts;  Cross-disciplinary;  Development and operations;  Multiple-case study;  Semi structured interviews;  Software engineering artifact;  Through the lens, Knowledge management",cited By 0,Investigating Software Engineering Artifacts in DevOps Through the Lens of Boundary Objects,ACM International Conference Proceeding Series,2023,EASE,conf
"Mobile app development frameworks lower the effort to write and deploy apps across different execution platforms. At the same time, their use may limit native optimizations and impose overhead, increasing resource usage. In this paper, we analyze the resource usage of Android benchmarks and apps based on three mobile app development frameworks, Flutter, React Native, and Ionic, comparing them to functionally equivalent, native variants written in Java. These frameworks, besides being in widespread use, represent three different approaches for developing multiplatform apps: Flutter supports the deployment of apps that are compiled and run fully natively, React Native runs interpreted JavaScript code combined with native views for different platforms, and Ionic is based on web apps, which means that it does not depend on platform-specific details. We measure the energy consumption, execution time, and memory usage of ten optimized, CPU-intensive benchmarks, to gauge overhead in a controlled manner, and two applications, to measure their impact when running commonly mobile app functionalities. Our results show that cross-platform and hybrid frameworks can be competitive in CPU-intensive applications. In five of the ten benchmarks, at least one framework-based version exhibits lower energy consumption and execution time than its native counterpart, up to a reduction of 81% in energy and 83% in execution time. Furthermore, in three other benchmarks, framework-based and native versions achieved similar results. Overall, Flutter, usually imposes the least overhead in execution time and energy, while React Native imposes the highest in all the benchmarks. However, in an app that continuously animates multiple images on the screen, without interaction, the React Native version uses the least CPU and energy, up to a reduction of 96% in energy compared to the second-best framework-based version. These findings highlight the importance of analyzing expected application behavior before committing to a specific framework. © 2023 ACM.",,"Oliveira, W. and Moraes, B. and Castor, F. and Fernandes, J.P.",,10.1145/3593434.3593487,Instituto Nacional de Ciencia e Tecnologia para Engenharia de Software,Brazil,"This research was partially by FEDER from the European Union through CENTRO 2020 under project CENTRO-01-0247-FEDER-047256 – GreenStamp: Mobile Energy Efficiency Services, and Base Funding - UIDB/00027/2020 of the Artificial Intelligence and Computer Science Laboratory – LIACC - by national funds through the FCT/MCTES (PIDDAC), and by FCT in the LASIGE Research Unit under the ref. UIDB/00408/2020 and UIDP/00408/2020 and the RAP project under the reference EXPL/CCI-COM/1306/2021, and INES 2.0, (FACEPE PRONEX APQ 0388-1.03/14 and APQ-0399-1.03/17, CNPq 465614/2014-0).","Benchmarking;  Flutter (aerodynamics), % reductions;  CPU-intensive;  Development frameworks;  Energy;  Execution platforms;  Javascript;  Mobile app;  Multi-platform;  Optimisations;  Resource usage, Energy utilization",cited By 1,Analyzing the Resource Usage Overhead of Mobile App Development Frameworks,ACM International Conference Proceeding Series,2023,EASE,conf
"This research explores the challenges in agile contract modeling for software innovation projects, particularly for outsourced projects. Literature has presented various methods and frameworks for agile contract management, but there is still a gap in effectively establishing the best contract approach for each project based on specific conditions. This work aims to contribute with a framework definition that effectively applies practical approaches for contract deployment suitable for software innovation projects, considering the best contractual practices related to projects specific context. The study will conduct an action research at CESAR, a prominent Brazilian Institute of Science and Technology (ICT) with 1200 employees and 26 years old, to establish effective agile contract models and its implementation that better support agile management and project success. The study hopes to contribute to understanding the relationship between the type of contract and project outcomes and to provide better agile contract implementation for software innovation projects developed by outsourced companies. © 2023 ACM.",Agile contracts;  Agile project management;  Pricing and contract design;  Software project management,"Gomes, A.",,10.1145/3593434.3593473,Instituto Nacional de Ciencia e Tecnologia para Engenharia de Software,Brazil,,"Human resource management;  Project management;  Software engineering, Agile contract;  Agile project management;  Contract design;  Contract management;  Innovation programs;  Outsourced projects;  Pricing and contract design;  Project-based;  Software innovations;  Software project management, Costs",cited By 0,Effective Agile Contracts Framework for Software Innovation Projects,ACM International Conference Proceeding Series,2023,EASE,conf
"Technical debt is often the result of Short Run decisions made during code development, which can lead to long-term maintenance costs and risks. Hence, evaluating the progression of a project and understanding related code quality aspects is essential. Fortunately, the prioritization process for addressing technical debt can be expedited with code analysis tools like the established SonarQube. Unfortunately, we experienced some limitations with this tool and have had some requirements from the industry that were not yet addressed. Through this experience report and the analysis of scientific papers, this work contributes: (1) a reassessment of technical debt within the industry, (2) considers the benefits of employing SonarQube as well as its limitations when evaluating and prioritizing technical debt, (3) introduces a novel tool named SoHist which addresses these limitations and offers additional features for the assessment and prioritization of technical debt, and (4) exemplifies the usage of this tool in two industrial settings in the ITEA3 SmartDelta project. © 2023 Owner/Author.",software quality evolution;  SoHist;  SonarQube;  technical debt,"Dornauer, B. and Felderer, M. and Weinzerl, J. and Racasan, M.-C. and Hess, M.",,10.1145/3593434.3593460,ITEA,EU,"This work has been supported by and done in the scope of the ITEA3 SmartDelta project, which has been funded by the Austrian Research Promotion Agency (Grant No. 890417) and the German Federal Ministry of Education and Research (Grant No. 01IS21083A).","Quality control, Code analysis;  Code development;  Long-term maintenances;  Maintenance cost;  Short runs;  Software Quality;  Software quality evolution;  Sohist;  Sonarqube;  Technical debts, Computer software selection and evaluation",cited By 1,SoHist: A Tool for Managing Technical Debt through Retro Perspective Code Analysis,ACM International Conference Proceeding Series,2023,EASE,conf
"Changes to a software project are inevitable as the software requires continuous adaptations, improvements, and corrections throughout maintenance. Identifying the purpose and impact of changes made to the codebase is critical in software engineering. However, manually identifying and characterizing software changes can be a time-consuming and tedious process that adds to the workload of software engineers. To address this challenge, several attempts have been made to automatically identify and demystify intents of software changes based on software artifacts such as commit change logs, issue reports, change messages, source code files, and software documentation. However, these existing approaches have their limitations. These include a lack of data, limited performance, and an inability to evaluate compound changes. This paper presents a doctoral research proposal that aims to automate the process of identifying commit-level changes in software projects using software repository mining and code representation learning models. The research background, state-of-The-Art, research objectives, research agenda, and threats to validity are discussed. © 2023 ACM.",code commit;  machine learning;  mining software repositories;  neural source code embeddings;  software maintenance,"Heričko, T.",,10.1145/3593434.3593505,Javna Agencija za Raziskovalno Dejavnost RS,Slovenia,The authors acknowledge the financial support from the Slovenian Research Agency (Research Core Funding No. P2-0057).,"Codes (symbols);  Machine learning, Code commit;  Code representation;  Embeddings;  Machine-learning;  Mining software;  Mining software repository;  Neural source code embedding;  Software change;  Software repositories;  Source codes, Computer software maintenance",cited By 0,Automatic Data-Driven Software Change Identification via Code Representation Learning,ACM International Conference Proceeding Series,2023,EASE,conf
"Code review is a common practice in software development and often conducted before code changes are merged into the code repository. A number of approaches for automatically recommending appropriate reviewers have been proposed to match such code changes to pertinent reviewers. However, such approaches are generic, i.e., they do not focus on specific types of issues during code reviews. In this paper, we propose an approach that focuses on architecture violations, one of the most critical type of issues identified during code review. Specifically, we aim at automating the recommendation of code reviewers, who are potentially qualified to review architecture violations, based on reviews of code changes. To this end, we selected three common similarity detection methods to measure the file path similarity of code commits and the semantic similarity of review comments. We conducted a series of experiments on finding the appropriate reviewers through evaluating and comparing these similarity detection methods in separate and combined ways with the baseline reviewer recommendation approach, RevFinder. The results show that the common similarity detection methods can produce acceptable performance scores and achieve a better performance than RevFinder. The sampling techniques used in recommending code reviewers can impact the performance of reviewer recommendation approaches. We also discuss the potential implications of our findings for both researchers and practitioners. © 2023 ACM.",Architecture Violation;  Code Review;  Reviewer Recommendation,"Li, R. and Liang, P. and Avgeriou, P.",,10.1145/3593434.3593450,National Natural Science Foundation of China,China,This work is funded by NSFC with No. 62172311 and the Special Fund of Hubei Luojia Laboratory.,"Software design, Acceptable performance;  Architecture violation;  Code changes;  Code review;  Detection methods;  Exploratory studies;  Performance;  Reviewer recommendation;  Semantic similarity;  Similarity detection, Semantics",cited By 0,Code Reviewer Recommendation for Architecture Violations: An Exploratory Study,ACM International Conference Proceeding Series,2023,EASE,conf
"Architecting software-intensive systems can be a complex process. It deals with the daunting tasks of unifying stakeholders' perspectives, designers' intellect, tool-based automation, pattern-driven reuse, and so on, to sketch a blueprint that guides software implementation and evaluation. Despite its benefits, architecture-centric software engineering (ACSE) suffers from a multitude of challenges. ACSE challenges could stem from a lack of standardized processes, socio-technical limitations, and scarcity of human expertise etc. that can impede the development of existing and emergent classes of software. Software Development Bots (DevBots) trained on large language models can help synergise architects' knowledge with artificially intelligent decision support to enable rapid architecting in a human-bot collaborative ACSE. An emerging solution to enable this collaboration is ChatGPT, a disruptive technology not primarily introduced for software engineering, but is capable of articulating and refining architectural artifacts based on natural language processing. We detail a case study that involves collaboration between a novice software architect and ChatGPT to architect a service-based software. Future research focuses on harnessing empirical evidence about architects' productivity and explores socio-technical aspects of architecting with ChatGPT to tackle challenges of ACSE. © 2023 Owner/Author.",ChatGPT;  DevBots;  Large Language Models;  Software Architecture,"Ahmad, A. and Waseem, M. and Liang, P. and Fahmideh, M. and Aktar, M.S. and Mikkonen, T.",,10.1145/3593434.3593468,National Natural Science Foundation of China,China,,"Computational linguistics;  Decision support systems;  Groupware;  Natural language processing systems;  Refining;  Reusability;  Software architecture;  Software design, Architecture-centric;  Centric softwares;  ChatGPT;  Collaborative softwares;  Complex Processes;  Development bot;  Language model;  Large language model;  Software architecting;  Software intensive systems, Computer software reusability",cited By 7,Towards Human-Bot Collaborative Software Architecting with ChatGPT,ACM International Conference Proceeding Series,2023,EASE,conf
"GitHub Actions is a powerful tool for automating workflows on GitHub repositories, with thousands of Actions currently available on the GitHub Marketplace. So far, the research community has conducted mining studies on Actions, with much of the focus on CI/CD. However, the motivation and best practices of developers for using, developing, and debugging Actions are unknown. To address this gap, we conducted a survey study with 90 Action users and developers. Our findings indicate that developers prefer Actions with verified creators and more stars when choosing between similar Actions, and often switch to alternative Actions when faced with bugs or a lack of documentation. We also found that developers find the composition of YAML files, which are essential for Action integration, challenging and error-prone. They primarily rely on QA forums to fix issues with these YAML files. Finally, we observed that developers would not likely adopt Actions when there are concerns around complexity and security risks. Our study summarizes developers' perceptions, decision-making process, and challenges in using, developing, and debugging Actions. We provide recommendations for improving the visibility, re-usability, documentation, and support surrounding GitHub Actions. © 2023 ACM.",developer's perception;  GitHub Actions;  open source;  software engineering;  survey;  workflow automation,"Saroar, S.G. and Nayebi, M.",,10.1145/3593434.3593475,Natural Sciences and Engineering Research Council of Canada,Canada,This research was partially supported by the NSERC Discovery Grant RGPIN-2019-05697.,"Decision making;  Open source software, Best practices;  Developer perception;  Error prones;  Github action;  Open-source;  Research communities;  Security risks;  Survey analysis;  Work-flows;  Workflow automation, Open systems",cited By 2,Developers' Perception of GitHub Actions: A Survey Analysis,ACM International Conference Proceeding Series,2023,EASE,conf
"With the recent advent of artificially intelligent pairing partners in software engineering, it is interesting to renew the study of the psychology of pairing. Pair programming provides an attractive way of teaching software engineering to university students. Its study can also lead to a better understanding of the needs of professional software engineers in various programming roles and for the improvement of the concurrent pairing software. [Objective] This preliminary study aimed to gain quantitative and qualitative insights into pair programming, especially students' attitudes towards its specific roles and what they require from the pairing partners. The research's goal is to use the findings to design further studies on pairing with artificial intelligence. [Method] Using a mixed-methods and experimental approach, we distinguished the effects of the pilot, navigator, and solo roles on (N = 35) students' intrinsic motivation. Four experimental sessions produced a rich data corpus in two software engineering university classrooms. It was quantitatively investigated using the Shapiro-Wilk normality test and one-way analysis of variance (ANOVA) to confirm the relations and significance of variations in mean intrinsic motivation in different roles. Consequently, seven semi-structured interviews were conducted with the experiment's participants. The qualitative data excerpts were subjected to the thematic analysis method in an essentialist way. [Results] The systematic coding interview transcripts elucidated the research topic by producing seven themes for understanding the psychological aspects of pair programming and for its improvement in university classrooms. Statistical analysis of 612 self-reported intrinsic motivation inventories confirmed that students find programming in pilot-navigator roles more interesting and enjoyable than programming simultaneously. [Conclusion] The executed experimental settings are viable for inspecting the associations between students' attitudes and the distributed cognition practice. The preliminary results illuminate the psychological aspects of the pilot-navigator roles and reveal many areas for improvement. The results also provide a strong basis for conducting further studies with the same design involving the big five personality and intrinsic motivation on using artificial intelligence in pairing and to allow comparison of those results with results of pairing with human partners. © 2023 Owner/Author.",Agile development;  Intrinsic motivation;  Pair programming;  Software engineering;  Thematic analysis,"Valovy, M.",,10.1145/3593434.3593458,Prague University of Economics and Business,Czech Republic,This work was supported by an internal grant funding scheme (F4/61/2023) administered by the Prague University of Economics and Business.,"Air navigation;  Analysis of variance (ANOVA);  Artificial intelligence;  Motivation;  Students, Agile development;  Intrinsic motivation;  Pair-programming;  Professional software engineers;  Psychological Aspects;  Student attitudes;  Teaching software;  Thematic analysis;  University classrooms;  University students, Software engineering",cited By 1,Psychological aspects of pair programming,ACM International Conference Proceeding Series,2023,EASE,conf
"Data quality assessment has become a prominent component in the successful execution of complex data-driven artificial intelligence (AI) software systems. In practice, real-world applications generate huge volumes of data at speeds. These data streams require analysis and preprocessing before being permanently stored or used in a learning task. Therefore, significant attention has been paid to the systematic management and construction of high-quality datasets. Nevertheless, managing voluminous and high-velocity data streams is usually performed manually (i.e. offline), making it an impractical strategy in production environments. To address this challenge, DataOps has emerged to achieve life-cycle automation of data processes using DevOps principles. However, determining the data quality based on a fitness scale constitutes a complex task within the framework of DataOps. This paper presents a novel Data Quality Scoring Operations (DQSOps) framework that yields a quality score for production data in DataOps workflows. The framework incorporates two scoring approaches, an ML prediction-based approach that predicts the data quality score and a standard-based approach that periodically produces the ground-truth scores based on assessing several data quality dimensions. We deploy the DQSOps framework in a real-world industrial use case. The results show that DQSOps achieves significant computational speedup rates compared to the conventional approach of data quality scoring while maintaining high prediction performance. © 2023 Owner/Author.",Automated data scoring;  data assessment;  data quality dimensions;  DataOps;  mutation testing,"Bayram, F. and Ahmed, B.S. and Hallin, E. and Engman, A.",,10.1145/3593434.3593445,Stiftelsen foer Kunskaps- och Kompetensutveckling;Stiftelsen för Kunskaps- och Kompetensutveckling,Sweden,This work has been funded by the Knowledge Foundation of Sweden (KKS) through the Synergy Project AIDA - A Holistic AI-driven Networking and Processing Framework for Industrial IoT (Rek:20200067).,"Data reduction;  Quality control, Automated data;  Automated data scoring;  Data assessment;  Data quality;  Data quality dimensions;  Data stream;  Data-driven applications;  Dataops;  Mutation testing;  Real-world, Life cycle",cited By 0,DQSOps: Data Quality Scoring Operations Framework for Data-Driven Applications,ACM International Conference Proceeding Series,2023,EASE,conf
"Binary classifiers are commonly used in software engineering research to estimate several software qualities, e.g., defectiveness or vulnerability. Thus, it is important to adequately evaluate how well binary classifiers perform, before they are used in practice. The Area Under the Curve (AUC) of Receiver Operating Characteristic curves has often been used to this end. However, AUC has been the target of some criticisms, so it is necessary to evaluate under what conditions and to what extent AUC can be a reliable performance metric. We analyze AUC in relation to φ (also known as Matthews Correlation Coefficient), often considered a more reliable performance metric, by building the lines in the ROC space with constant value of φ, for several values of φ, and computing the corresponding values of AUC. By their very definitions, AUC and φ depend on the prevalence ρ of a dataset, which is the proportion of its positive instances (e.g., the defective software modules). Hence, so does the relationship between AUC and φ. It turns out that AUC and φ are very well correlated, and therefore provide concordant indications, for balanced datasets (those with ρ g 0.5). Instead, AUC tends to become quite large, and hence provide over-optimistic indications, for very imbalanced datasets (those with ρ g 0 or ρ g 1). We use examples from the software engineering literature to illustrate the analytical relationship linking AUC, φ, and ρ. We show that, for some values of ρ, the evaluation of performance based exclusively on AUC can be deceiving. In conclusion, this paper provides some guidelines for an informed usage and interpretation of AUC. © 2023 ACM.",accuracy;  Binary classifiers;  Matthews Correlation Coefficient.;  Pearson φ;  performance metrics;  predictors,"Lavazza, L. and Morasca, S. and Rotoloni, G.",,10.1145/3593434.3593456,Universita degli Studi dell'Insubria,Italy,This work has been supported by the “Fondo di Ricerca d’Ateneo” funded by the Università degli Studi dell’Insubria.,"Computer software selection and evaluation;  Defects;  Large dataset;  Professional aspects;  Software reliability, Accuracy;  Area under the ROC curve;  Areas under the curves;  Binary classifiers;  Correlation coefficient;  Matthew correlation coefficient.;  Pearson φ;  Performance metrices;  Predictor;  Reliable performance, Classification (of information)",cited By 1,On the Reliability of the Area under the ROC Curve in Empirical Software Engineering,ACM International Conference Proceeding Series,2023,EASE,conf
"Architecting software-intensive systems can be a complex process. It deals with the daunting tasks of unifying stakeholders' perspectives, designers' intellect, tool-based automation, pattern-driven reuse, and so on, to sketch a blueprint that guides software implementation and evaluation. Despite its benefits, architecture-centric software engineering (ACSE) suffers from a multitude of challenges. ACSE challenges could stem from a lack of standardized processes, socio-technical limitations, and scarcity of human expertise etc. that can impede the development of existing and emergent classes of software. Software Development Bots (DevBots) trained on large language models can help synergise architects' knowledge with artificially intelligent decision support to enable rapid architecting in a human-bot collaborative ACSE. An emerging solution to enable this collaboration is ChatGPT, a disruptive technology not primarily introduced for software engineering, but is capable of articulating and refining architectural artifacts based on natural language processing. We detail a case study that involves collaboration between a novice software architect and ChatGPT to architect a service-based software. Future research focuses on harnessing empirical evidence about architects' productivity and explores socio-technical aspects of architecting with ChatGPT to tackle challenges of ACSE. © 2023 Owner/Author.",ChatGPT;  DevBots;  Large Language Models;  Software Architecture,"Ahmad, A. and Waseem, M. and Liang, P. and Fahmideh, M. and Aktar, M.S. and Mikkonen, T.",,10.1145/3593434.3593468,University of Jyvaeskylae,Finland,"This work is funded by the University of Jyväskylä, Finland research grant, and the NSFC China with grant number 62172311.","Computational linguistics;  Decision support systems;  Groupware;  Natural language processing systems;  Refining;  Reusability;  Software architecture;  Software design, Architecture-centric;  Centric softwares;  ChatGPT;  Collaborative softwares;  Complex Processes;  Development bot;  Language model;  Large language model;  Software architecting;  Software intensive systems, Computer software reusability",cited By 7,Towards Human-Bot Collaborative Software Architecting with ChatGPT,ACM International Conference Proceeding Series,2023,EASE,conf
"Since internet applications have reached a satisfactory level of maturity, large information systems have been developed to manage and facilitate access to documents. Simultaneously, there was an enormous international effort to digitise documents, enabling access via the internet. This endeavour facilitated the access of researchers to extensive document repositories and libraries, while also aiding companies in organising their documents. Two decades later, these vast databases are reasonably clean and well-organised, although the software used to manage and feed them is gradually becoming obsolete. Therefore, it is imperative to continuously reengineer the software to maintain optimal functionality. Furthermore, after the initial effort to digitise documents and create the initial metadata, it is reasonable to augment the metadata information pertaining to the documents. As such, two necessities are apparent: improving support for reengineering legacy document information systems and enabling data model updates and schema evolution to accommodate new information. Our goal is to automate the reengineering process as a whole. © 2023 ACM.",automated development;  document information systems;  schema evolution;  software reengineering,"Ramos-Vidal, D.",,10.1145/3593434.3593436,Xunta de Galicia,Spain,"CITIC is funded by the Xunta de Galicia through the collaboration agreement between the Department of Culture, Education, Vocational Training and Universities and the Galician universities for the reinforcement of the research centers of the Galician University System (CIGUS); PID2021-122554OB-C33 (OASSIS): partially funded by MCIN/AEI/10.13039/501100011033 and EU/ERDF A way of making Europe; TED2021-129245B-C21 (PLAGEMIS): partially funded by MCIN/AEI/10.13039/501100011033 and “NextGen-erationEU”/PRTR; PID2020-114635RB-I00 (EXTRACompact): partially funded by MCIN/ AEI/10.13039/501100011033; GRC: ED431C 2021/53, partially funded by GAIN/Xunta de Galicia; PRE2021-099351, partially funded by MCIN/AEI/10.13039/501100011033 and “FSE+""Fondo Social Europeo Plus"".","Information management;  Information systems;  Information use;  Legacy systems;  Metadata, Automated development;  Document information systems;  Document repositories;  Internet application;  Legacy documents;  Metadata information;  Model updates;  Schema evolution;  Software reengineering, Reengineering",cited By 0,Reengineering legacy document information systems: Challenges and solutions,ACM International Conference Proceeding Series,2023,EASE,conf
"Making sub-optimal design decisions during software development leads to the accumulation of Technical Debt (TD) in software projects. There are tools to identify TD Items in software code through static code analysis. However, quantifying TD to support decision-making on whether to keep taking on TD or if it is time to refactor TD is a difficult task, and proposed approaches for this still lack consensus. Prior work observed that TD Interest could be further decomposed into constituents g New Code Cost' and g Rework Cost', which gives an interesting direction of research to explore TD quantification in terms of these costs. Therefore, through our empirical study, we plan to explore the relationship between TD, New Code Cost and Rework Cost in Open-Source Software Projects. This paper reports on an initial motivating study, our plan for future work and implications for researchers. © 2023 ACM.",mining software repositories;  technical debt management,"Perera, J. and Tempero, E. and Tu, Y.-C. and Blincoe, K.",,10.1145/3593434.3593490,,,,"Codes (symbols);  Open source software;  Open systems;  Software design, Empirical studies;  Mining software;  Mining software repository;  Open source software projects;  Optimal design decisions;  Rework costs;  Software repositories;  Sub-optimal designs;  Technical debt management;  Technical debts, Decision making",cited By 0,"Understanding the relationship between Technical Debt, New Code Cost and Rework Cost in Open-Source Software Projects: An Empirical Study",ACM International Conference Proceeding Series,2023,EASE,conf
"Kubernetes is a free, open-source container orchestration system for deploying and managing Docker containers that host microservices. Kubernetes cluster logs help in determining the reason for the failure. However, as systems become more complex, identifying failure reasons manually becomes more difficult and time-consuming. This study aims to identify effective and efficient classification algorithms to automatically determine the failure reason. We compare five classification algorithms, Support Vector Machines, K-Nearest Neighbors, Random Forest, Gradient Boosting Classifier, and Multilayer Perceptron. Our results indicate that Random Forest produces good accuracy while requiring fewer computational resources than other algorithms. © 2023 Owner/Author.",Kubernetes cluster logs;  machine learning;  microservices,"Sarika, P.K. and Badampudi, D. and Josyula, S.P. and Usman, M.",,10.1145/3593434.3593472,,,,"Failure (mechanical);  Nearest neighbor search;  Open systems;  Support vector machines, Classification algorithm;  Gradient boosting;  Kubernetes cluster log;  Machine-learning;  Microservice;  Nearest-neighbour;  Open-source;  Random forests;  Support vectors machine;  Test failure, Containers",cited By 0,Automating Microservices Test Failure Analysis using Kubernetes Cluster Logs,ACM International Conference Proceeding Series,2023,EASE,conf
"Many advanced program analysis and verification methods are based on solving systems of Constrained Horn Clauses (CHC). Testing CHC solvers is very important, as correctness of their work determines whether bugs in the analyzed programs are detected or missed. One of the well-established and efficient methods of automated software testing is fuzzing: analyzing the reactions of programs to random input data. Currently, there are no fuzzers for CHC solvers, and fuzzers for SMT solvers are not efficient in CHC solver testing, since they do not consider CHC specifics. In this paper, we present HornFuzz, a mutation-based gray-box fuzzing technique for detecting bugs in CHC solvers based on the idea of metamorphic testing. We evaluated our fuzzer on one of the highest performing CHC solvers, Spacer, and found a handful of bugs in Spacer. In particular, some discovered problems are so serious that they require fixes with significant changes to the solver. © 2023 ACM.",CHC solvers;  fuzzing;  metamorphic testing,"Sukhanova, A. and Sobol, V.",,10.1145/3593434.3593455,,,,"Logic programming;  Program debugging;  Well testing, Analysis and verifications;  Analysis method;  Automated software testing;  Constrained horn clause solver;  Fuzzing;  Horn clause;  Metamorphic testing;  Program analysis;  Program Verification;  Verification method, Software testing",cited By 0,HornFuzz: Fuzzing CHC solvers,ACM International Conference Proceeding Series,2023,EASE,conf
"In DevOps, the traceability of software artifacts is critical to the successful development and operation of project delivery to stakeholders. Before the introduction of end-to-end traceability in DevOps at a Data Analytics team at bp (BP plc), an international integrated energy company, the tracing of artifacts throughout a project life cycle was manual and time-consuming. This changed when traceability become more automated with end-to-end traceability capability as an offering on the platform. This paper reports on the ways of working and the experience of developers implementing DevOps for developing and putting in production a Javascript React web application, with a focus on traceability management of artifacts produced throughout the life cycle. This report highlights key opportunities and challenges in traceability management from the development stage to production. © 2023 Owner/Author.",Agile;  DevOps;  Industry;  Software traceability;  Web application,"Pauzi, Z. and Thind, R. and Capiluppi, A.",,10.1145/3593434.3593451,,,,"Application programs;  Data Analytics, Agile;  Development and operations;  End to end;  Experience report;  Industrial experience;  Software artefacts;  Software traceability;  Traceability managements;  WEB application;  Web applications, Life cycle",cited By 0,Artifact Traceability in DevOps: An Industrial Experience Report,ACM International Conference Proceeding Series,2023,EASE,conf
"Automated test generation has been extensively studied for dynamically compiled or typed programming languages like Java and Python. However, Go, a popular statically compiled and typed programming language for server application development, has received limited support from existing tools. To address this gap, we present NxtUnit, an automatic unit test generation tool for Go that uses random testing and is well-suited for microservice architecture. NxtUnit employs a random approach to generate unit tests quickly, making it ideal for smoke testing and providing quick quality feedback. It comes with three types of interfaces: an integrated development environment (IDE) plugin, a command-line interface (CLI), and a browser-based platform. The plugin and CLI tool allow engineers to write unit tests more efficiently, while the platform provides unit test visualization and asynchronous unit test generation. We evaluated NxtUnit by generating unit tests for 13 open-source repositories and 500 ByteDance in-house repositories, resulting in a code coverage of 20.74% for in-house repositories. We conducted a survey among Bytedance engineers and found that NxtUnit can save them 48% of the time on writing unit tests. We have made the CLI tool available at https://github.com/bytedance/nxt_unit. © 2023 ACM.",Automated Test Generation;  Go,"Wang, S. and Mao, X. and Cao, Z. and Gao, Y. and Shen, Q. and Peng, C.",,10.1145/3593434.3593443,,,,"Automation;  Computer programming languages;  Open systems;  Smoke;  Software testing;  Well testing, Application development;  Automated test generations;  Automated units;  Command line;  Go;  Interface tools;  Plug-ins;  Server applications;  Unit test generations;  Unit tests, Open source software",cited By 0,NxtUnit: Automated Unit Test Generation for Go,ACM International Conference Proceeding Series,2023,EASE,conf
"Code smells is the term used to signal certain patterns or structures in software code that may contain a potential design or architecture problem, leading to maintainability or other software quality issues. Detecting code smells early in the software development process helps prevent these problems and improve the overall software quality. Existing research concentrates on the process of collecting and handling dataset, then exploring the potential of utilizing deep learning models to detect smells, while ignoring extensive feature engineering. Though these approaches obtained promising results, the following issues need to be tackled: (i) extracting both structural and semantic features from the software units; (ii) mitigating the effects of imbalanced data distribution on the performance.In this paper, we propose DeepSmells as a novel approach to code smells detection. To learn the complex hierarchical representations of the code fragment, we apply a deep convolutional neural network (CNN). Then, in order to improve the quality of the context encoding and preserve semantic information, long short-term memory networks (LSTM) is placed immediately after the CNN. The final classification is conducted by deep neural networks with weighted loss function to reduce the impact of skewed data distribution. We performed an empirical study using the existing code smell benchmark datasets to assess the performance of our proposed approach, and compare it with state-of-the-art baselines. The results demonstrate the effectiveness of our proposed method for all kinds of code smells with outperformed evaluation metrics in terms of F1 score and MCC. © 2023 ACM.",,"Ho, A. and Bui, A.M.T. and Nguyen, P.T. and Di Salle, A.",,10.1145/3593434.3593476,,,,"Benchmarking;  Codes (symbols);  Convolution;  Convolutional neural networks;  Deep neural networks;  Network coding;  Odors;  Semantics;  Software design, Automated detection;  Code smell;  Convolutional neural network;  Data distribution;  Memory network;  Performance;  Quality issues;  Software codes;  Software development process;  Software Quality, Long short-term memory",cited By 1,Fusion of deep convolutional and LSTM recurrent neural networks for automated detection of code smells,ACM International Conference Proceeding Series,2023,EASE,conf
"Background: Construct validity concerns the use of indicators to measure a concept that is not directly measurable. Aim: This study intends to identify, categorize, assess and quantify discussions of threats to construct validity in empirical software engineering literature and use the findings to suggest ways to improve the reporting of construct validity issues. Method: We analyzed 83 articles that report human-centric experiments published in five top-tier software engineering journals from 2015 to 2019. The articles' text concerning threats to construct validity was divided into segments (the unit of analysis) based on predefined categories. The segments were then evaluated regarding whether they clearly discussed a threat and a construct. Results: Three-fifths of the segments were associated with topics not related to construct validity. Two-thirds of the articles discussed construct validity without using the definition of construct validity given in the article. The threats were clearly described in more than four-fifths of the segments, but the construct in question was clearly described in only two-thirds of the segments. The construct was unclear when the discussion was not related to construct validity but to other types of validity. Conclusions: The results show potential for improving the understanding of construct validity in software engineering. Recommendations addressing the identified weaknesses are given to improve the awareness and reporting of CV. © 2023 Owner/Author.",empirical research;  measurement;  research quality,"Sjøberg, D.I.K. and Bergersen, G.R.",,10.1145/3593434.3593449,,,,"Computer programming, Construct validity;  Empirical research;  Empirical Software Engineering;  Human-centric;  Research quality;  Software engineering journals;  Unit of analysis, Software engineering",cited By 1,Improving the Reporting of Threats to Construct Validity,ACM International Conference Proceeding Series,2023,EASE,conf
"In this study, we assess bug life cycles to identify bottlenecks in the bug tracking processes, and examine the effectiveness of bug tracking system usage practices linked to bug states and state transitions. To achieve this, we examined the bug life cycles of three open-source software projects which use Bugzilla as their bug tracking system. In total, we have analyzed 106.196 bugs gathered from these projects. We started by looking at the temporal and quantitative aspects of these projects' bug life cycles. After that, we collected data about how bug life cycles differ over time. Finally, we inspected the frequency of reopened and state-looping bugs in these projects. After our analysis, we have deduced that the presented temporal and quantitative analysis of bug life cycles is useful for finding bottlenecks and undesired behaviors in the bug tracking processes. We also inferred that examining the changes in bug life cycles over time can provide insights into how bug tracking practices changed throughout the project's lifetime, and it can be used as a parameter to assess whether the bug tracking system usage has improved. Lastly, we deducted that analyzing undesired state trails' frequency provides insights into the performance of bug tracking processes. Based on the insights gained from analyzing bug life cycles with the presented methods, we believe that decision makers can improve their workflow by introducing or removing new states to the bug life cycle and adding new rules and restrictions to their bug tracking process. © 2023 Owner/Author.",bug life cycle;  bug tracking;  bug tracking system;  issue tracking;  state trails,"Eren, C. and Sahin, K. and Tüzün, E.",,10.1145/3593434.3593504,,,,"Decision making;  Open source software;  Open systems;  Tracking (position), Bug life cycle;  Bug tracking;  Bug tracking system;  Issue Tracking;  Open source software projects;  State trail;  State transitions;  System usages;  Tracking process;  Undesired behavior, Life cycle",cited By 0,Analyzing Bug Life Cycles to Derive Practical Insights,ACM International Conference Proceeding Series,2023,EASE,conf
"The exponential increase in smartphone usage has fueled the rapid growth of Android applications (apps). Unfortunately, this growth has also resulted in an alarming rise in security vulnerabilities, posing a significant challenge for developers of smartphone apps. In this paper, we conducted a quantitative and qualitative study to analyze security-related issues in open-source Android apps available on GitHub. Our study included a total set of 689 security-related commits identified from 111,224 commits distributed over 2,187 apps. We proposed a taxonomy of ten distinct categories of security issues, which we identified using the card-sorting technique. Our findings showed that Permission issues were the most prevalent in our dataset (370, 53.7%), followed by Login issues (160, 23.22%). Issues such as Privacy (5, 0.72%) and Framework (3, 0.43%) were rare in our dataset. These preliminary findings serve as an initial step towards comprehending the primary security concerns from the perspective of both developers and researchers. © 2023 Owner/Author.",Android apps;  Card sorting;  Security-related commits,"Das, T. and Ali, A. and Mikkonen, T.",,10.1145/3593434.3593437,,,,"Android (operating system);  Mobile security, Android applications;  Android apps;  Card-sorting;  Exponential increase;  Quantitative study;  Rapid growth;  Security vulnerabilities;  Security-related commit;  Smart phones;  Smart-phone applications, Smartphones",cited By 0,Investigation of Security-related Commits in Android Apps,ACM International Conference Proceeding Series,2023,EASE,conf
"One of the objectives of software engineering education is to make students to learn essential teamwork skills. This is done by having the students work in groups for course assignments. Student team composition plays a vital role in this, as it significantly affects learning outcomes, what is learned, and how. The study presented in this paper aims to better understand the student team composition in software engineering education and investigate the factors affecting it in the international software engineering education context. Those factors should be taken into consideration by software engineering teachers when they design group work assignments in their courses. In this paper, the initial findings of the ongoing Action research study are presented. The results give some identified principles that should be considered when designing student team composition in software engineering courses. © 2023 Owner/Author.",education;  Software engineering;  team composition;  teamwork,"Hashmi, S.I. and Markkula, J.",,10.1145/3593434.3593464,,,,"Curricula;  Engineering education;  Engineering research;  Software engineering, Engineering teachers;  Group work;  Learn+;  Learning outcome;  Software engineering education;  Student teams;  Team composition;  Teamwork;  Teamwork skills;  Work assignments, Students",cited By 0,Team Composition in Software Engineering Education,ACM International Conference Proceeding Series,2023,EASE,conf
"Requirements Engineering (RE) and Software Testing (ST) phases are essential to software development. Acknowledging the emergence of cognitive biases, systematic divergences from optimum decision-making, is crucial in software development because of the extensive human participation in various roles. How information is presented can impact decision-making, known as the framing effect - a cognitive bias. The framing effect hinders creativity in software design during the requirements phase. This cognitive effect may further lead to another bias - confirmation bias - in ST. Confirmation bias in ST is testing requirements-consistent behaviors instead of requirements-inconsistent ones. This research explores the effects of framing software requirements on the manifestation of confirmation bias during testing. Additionally, the work aims to propose mitigation strategies, referred to as debiasing, for framing and confirmation bias in the context of ST. This work employs both quantitative and qualitative empirical methods to address its aims. Hence, this research will explore the relation between the framing of requirements and the confirmation bias during ST. Furthermore, this research will also develop debiasing techniques to mitigate the negative effects of these biases to improve software quality. © 2023 Owner/Author.",cognitive bias;  confirmation bias;  framing requirements;  requirements engineering;  software engineering;  software testing,"Jahin, A.",,10.1145/3593434.3593447,,,,"Computer software selection and evaluation;  Decision making;  Engineering research;  Requirements engineering;  Software design, Cognitive bias;  Confirmation bias;  De-biasing;  Decisions makings;  Framing effects;  Framing requirement;  Optimum decision;  Requirement engineering;  Software testings;  Testing phase, Software testing",cited By 0,Investigating the Relation between Requirements Framing and Confirmation Bias in Testing,ACM International Conference Proceeding Series,2023,EASE,conf
"Industrial applications heavily integrate open-source software libraries nowadays. Beyond the benefits that libraries bring, they can also impose a real threat in case a library is affected by a vulnerability but its community is not active in creating a fixing release. Therefore, I want to introduce an automatic monitoring approach for industrial applications to identify open-source dependencies that show negative signs regarding their current or future maintenance activities. Since most research in this field is limited due to lack of features, labels, and transitive links, and thus is not applicable in industry, my approach aims to close this gap by capturing the impact of direct and transitive dependencies in terms of their maintenance activities. Automatically monitoring the maintenance activities of dependencies reduces the manual effort of application maintainers and supports application security by continuously having well-maintained dependencies. © 2023 ACM.",Maintenance Activities;  OSS Libraries;  Repository Mining,"Tsakpinis, A.",,10.1145/3593434.3593474,,,,"Application programs;  Computer software maintenance;  Libraries;  Open systems, Automatic monitoring;  Community IS;  Maintenance activity;  Monitoring approach;  Open-source;  Open-source softwares;  OSS library;  Repository mining;  Software libraries;  Source dependency, Open source software",cited By 0,Analyzing Maintenance Activities of Software Libraries,ACM International Conference Proceeding Series,2023,EASE,conf
"With the arising concerns of privacy within machine learning, federated learning (FL) was invented in 2017, in which the clients, such as mobile devices, train a model and send the update to the centralized server. Choosing clients randomly for FL can harm learning performance due to different reasons. Many studies have proposed approaches to address the challenges of client selection of FL. However, no systematic literature review (SLR) on this topic existed. This SLR investigates the state of the art of client selection in FL and answers the challenges, solutions, and metrics to evaluate the solutions. We systematically reviewed 47 primary studies. The main challenges found in client selection are heterogeneity, resource allocation, communication costs, and fairness. The client selection schemes aim to improve the original random selection algorithm by focusing on one or several of the aforementioned challenges. The most common metric used is testing accuracy versus communication rounds, as testing accuracy measures the successfulness of the learning and preferably in as few communication rounds as possible, as they are very expensive. Although several possible improvements can be made with the current state of client selection, the most beneficial ones are evaluating the impact of unsuccessful clients and gaining a more theoretical understanding of the impact of fairness in FL. © 2023 Owner/Author.",client selection;  federated learning;  neural network;  software metric;  systematic literature review,"Smestad, C. and Li, J.",,10.1145/3593434.3593438,,,,"Centralized server;  Client selection;  Communication rounds;  Federated learning;  Learning performance;  Machine-learning;  Neural-networks;  Software metrics;  Systematic literature review;  Testing accuracy, Learning systems",cited By 0,A Systematic Literature Review on Client Selection in Federated Learning,ACM International Conference Proceeding Series,2023,EASE,conf
"Fault-proneness is an indication of programming errors that decreases software quality and maintainability. On the contrary, code smell is a symptom of potential design problems which has impact on fault-proneness. In the literature, negative impact of code smells on fault-proneness has been investigated. However, it is still unclear that how frequency of each code smell type impacts the fault-proneness. To mitigate this research gap, we present an empirical study to identify whether frequency of individual code smell types has a relationship with the fault-proneness. The results show that Anti Singleton, Blob and Class Data Should Be Private smell types have strong relationship with fault-proneness though their frequencies are not very high. On the other hand, comparatively high frequent code smell types such as Complex Class, Large Class and Long Parameter List have moderate relationship with fault-proneness. These findings will assist developers to prioritize and refactor code smells to improve software quality. © 2023 Owner/Author.",code smell;  empirical study;  fault proneness,"Rahman, M.M. and Ahammed, T. and Joarder, M.M.A. and Sakib, K.",,10.1145/3593434.3593457,,,,"Odors, Code smell;  Complex class;  Design problems;  Empirical studies;  Fault-proneness;  Programming errors;  Research gaps;  Software maintainability;  Software Quality, Computer software selection and evaluation",cited By 0,Does Code Smell Frequency Have a Relationship with Fault-proneness?,ACM International Conference Proceeding Series,2023,EASE,conf
"Background: The UK cyber skills gap/shortage amplifies the broader impact of cyber-attacks, which inflict harms such as privacy and economic loss on wider society. The demand is greatest (and growing fastest) in cyber-enabled disciplines, such as software engineering. Objectives: In this paper, we create a term frequency-inverse document frequency representation of the Cyber Security Body of Knowledge (CyBOK). We then evaluate the potential of this representation by using it to automatically map job descriptions to the different areas of the CyBOK. Method: We generate two representations of the CyBOK. The representations are mapped to a corpus of 454 job descriptions using TF-IDF. Comparing the similarity scores across these mappings allows us to identify relevant knowledge areas/groups. Results: The results are preliminary, but suggest that the approach warrants further investigation. Certain job descriptions are mapped to certain knowledge areas/groups in a way that makes intuitive sense to the authors. However, there is a degree homogeneity to the scores returned for certain knowledge areas/groups. There are several threats to validity, most notably the low number of job descriptions that have been studied. Conclusions: Our work shows that it is possible to automatically map job descriptions to the CyBOK in a meaningful way. Further research is required to address threats and to explore alternative mapping approaches. The authors intend to undertake this research culminating with a Grey Literature Informed Model of Practice in Secure Software Engineering. © 2023 Owner/Author.",Cyber Security;  CyBOK;  Grey Literature;  Higher Education;  Secure Software Development,"Attwood, S. and Williams, A.",,10.1145/3593434.3593459,,,,"Employment;  Inverse problems;  Losses;  Mapping;  Network security;  Semantics;  Software design;  Text processing, Body of knowledge;  Cybe security body of knowledge;  Cyber security;  Grey literature;  High educations;  Job description;  Knowledge areas;  Secure software development;  Skills gaps, Cybersecurity",cited By 0,Exploring the UK Cyber Skills Gap through a mapping of active job listings to the Cyber Security Body of Knowledge (CyBOK),ACM International Conference Proceeding Series,2023,EASE,conf
"The ability to allow developers to share their source code and collaborate on software projects has made GitHub a widely used open source platform. Each repository in GitHub is generally equipped with a README.MD file to exhibit an overview of the main functionalities. Nevertheless, while offering useful information, README.MD is usually lengthy, requiring time and effort to read and comprehend. Thus, besides README.MD, GitHub also allows its users to add a short description called ""About,""giving a brief but informative summary about the repository. This enables visitors to quickly grasp the main content and decide whether to continue reading. Unfortunately, due to various reasons-not excluding laziness-oftentimes this field is left blank by developers. This paper proposes GitSum as a novel approach to the summarization of README.MD. GitSum is built on top of BART and T5, two cutting-edge deep learning techniques, learning from existing data to perform recommendations for repositories with a missing description. We test its performance using two datasets collected from GitHub. The evaluation shows that GitSum can generate relevant predictions, outperforming a well-established baseline. © 2023 ACM.",GitHub;  mining software repositories;  README.MD;  recommender systems;  summarization,"Doan, T.T.H. and Nguyen, P.T. and Di Rocco, J. and Di Ruscio, D.",,10.1145/3593434.3593448,,,"This work has been partially supported by the EMELIOT national research project, which has been funded by the MUR under the PRIN 2020 program (Contract 2020W3A5FY).","Learning systems;  Open source software;  Open systems;  Petroleum reservoir evaluation, Automatic summarization;  Github;  MD;  Mining software;  Mining software repository;  README.;  Software project;  Software repositories;  Source codes;  Summarization, Deep learning",cited By 0,Too long; Didn't read: Automatic summarization of GitHub README.MD with Transformers,ACM International Conference Proceeding Series,2023,EASE,conf
"Society's increasing dependence on Artificial Intelligence (AI) and AI-enabled systems require a more practical approach from software engineering (SE) executives in middle and higher-level management to improve their involvement in implementing AI ethics by making ethical requirements part of their management practices. However, research indicates that most work on implementing ethical requirements in SE management primarily focuses on technical development, with scarce findings for middle and higher-level management. We investigate this by interviewing ten Finnish SE executives in middle and higher-level management to examine how they consider and implement ethical requirements. We use ethical requirements from the European Union (EU) Trustworthy Ethics guidelines for Trustworthy AI as our reference for ethical requirements and an Agile portfolio management framework to analyze implementation. Our findings reveal a general consideration of privacy and data governance ethical requirements as legal requirements with no other consideration for ethical requirements identified. The findings also show practicable consideration of ethical requirements as technical robustness and safety for implementation as risk requirements and societal and environmental well-being for implementation as sustainability requirements. We examine a practical approach to implementing ethical requirements using the ethical risk requirements stack employing the Agile portfolio management framework. © 2023 Owner/Author.",Agile portfolio management;  AI;  AI ethics;  AI ethics principles;  Ethical requirements;  Ethical requirements stack,"Agbese, M. and Mohanani, R. and Khan, A. and Abrahamsson, P.",,10.1145/3593434.3593453,,,"This research is supported by The Business Finland funded project Smart Terminals, SMARTER and Ministry of Education funded project AI-Forum.","Engineering research;  Financial data processing;  Philosophical aspects;  Software engineering;  Sustainable development, Agile portfolio management;  Artificial intelligence ethic;  Artificial intelligence ethic principle;  Engineering executives;  Ethical requirement;  Ethical requirement stack;  Level management;  Management frameworks;  Management practises;  Portfolio managements, Investments",cited By 0,Implementing AI Ethics: Making Sense of the Ethical Requirements,ACM International Conference Proceeding Series,2023,EASE,conf
"The purpose of this study is to identify the characteristics of Agile development processes that impact user satisfaction. We used user reviews of OSS smartphone apps and various data from version control systems to examine the relationships, especially time-series correlations, between user satisfaction and development metrics that are expected to be related to user satisfaction. Although no metrics conclusively indicate an improved user satisfaction, motivation of the development team, the ability to set appropriate work units, the appropriateness of work rules, and the improvement of code maintainability should be considered as they are correlated with improved user satisfaction. In contrast, changes in the release frequency and workload are not correlated. © 2023 Owner/Author.",Agile;  development process;  metric;  user satisfaction,"Yang, M. and Sato, S. and Washizaki, H. and Fukazawa, Y. and Takahashi, J.",,10.1145/3593434.3593470,,,,"Agile;  Agile development;  Development process;  Development teams;  Metric;  Smartphone apps;  Times series;  User reviews;  Users' satisfactions;  Version control system, Agile manufacturing systems",cited By 0,Identifying characteristics of the agile development process that impact user satisfaction,ACM International Conference Proceeding Series,2023,EASE,conf
"The use of social robots in public spaces is becoming increasingly popular due to their ability to provide personalized services to users. However, the convergence of different technologies and software applications has raised concerns regarding security requirements, standards, and regulations. Specifically, there are significant concerns about the evolving threat landscape for software applications in public settings, where social robots interact without supervision and are in direct contact with threat actors. During the development of social robots software, developers and practitioners need practical tools to continuously assess their products' security profiles. This paper presents a preventive approach to the dynamic evolving security landscape of Social Robots in Public Spaces (SRPS) using design science research (DSR) methodology to develop a security framework. The study investigates security threats, vulnerabilities, and risks associated with SRPS software development and analyzes existing related frameworks to design a security framework for SRPS software developers. The research aims to provide insights into the security aspects of SRPS software application development processes and contribute to developing effective security frameworks to mitigate evolving risks and ensure secure operation and acceptance in public spaces. © 2023 Owner/Author.",cybersecurity framework;  public space.;  social robots;  threat landscape,"Oruma, S.O.",,10.1145/3593434.3593446,,,This paper is funded by the Research Council of Norway under the SecuRoPS project “User-centered Security Framework for Social Robots in Public Spaces” with project code 321324.,"Application programs;  Cryptography;  Cybersecurity;  Economic and social effects;  Machine design;  Robots, Cyber security;  Cybersecurity framework;  Public space;  Public space.;  Security frameworks;  Social robots;  Software applications;  Software developer;  Threat landscape;  User-centred, Software design",cited By 1,Towards a User-centred Security Framework for Social Robots in Public Spaces,ACM International Conference Proceeding Series,2023,EASE,conf
"Most client software employs a bug-tracking system, which utilizes user-submitted reports (bug reports) that contain information necessary for software developers to fix bugs. The quality of bug reports drastically differs. Bug reports can include severity, priority, and associated issues determined by researching the addressed bug. Herein we investigate the influence of bug report qualities on successfully fixing a bug and estimating the fixing time. We also examine the claim in previous studies that bias and differences in the treatment of bug reports exist due to broad expertness among the reporters. Our approach examines the relationship between the qualities within the bug-fixing cycle and modeling graphical causal dependencies through a Bayesian Network. Bug reports with attachments, dependencies on another bug, and frequent discussions are more likely to be fixed. In addition, bug reports with a high severity tend to be fixed faster. Moreover, the difficulty of the bug itself may influence the fixing rate such that a straightforward bug will be fixed easier and faster regardless of the bug report quality. © 2023 Owner/Author.",Bayesian Network;  Bug Reports;  Causal and Inference Model,"Peralta, S.R.O. and Washizaki, H. and Fukazawa, Y. and Noyori, Y. and Nojiri, S. and Kanuka, H.",,10.1145/3593434.3593484,,,,"Program debugging;  Quality control, Bayesia n networks;  Bug reports;  Bug tracking system;  Bug-fixing;  Causal dependencies;  Causal modeling;  Client software;  Inference models;  Software developer, Bayesian networks",cited By 0,Analysis of Bug Report Qualities with Fixing Time using a Bayesian Network,ACM International Conference Proceeding Series,2023,EASE,conf
"The complexity of delivering enterprise-grade software, especially as-a-service, keeps getting more sophisticated even with the large set of open-source and commercial helper tools. Every single commit by the developers must go through a large group of checks to ensure that it will not break or regress reliability, resiliency, security, compliance, privacy, performance, accessibility, operability, etc. Being a developer or a software architect in such an environment is not a fulfilling role at all. Full stack, as a notion, is not applicable to large-scale systems and enterprise software. We are introducing a new, horizontal, approach called ""full-spec software,""where each layer of the system is architected, designed, and built with the long list of enterprise readiness attributes listed above. Making full-spec software a reality requires a new organizational construct called ""platform engineering."" © 2023 ACM.",Agile;  Compliance;  DevOps;  DevSecOps;  Full-Spec;  Full-Stack;  Platform;  Security;  SRE,"Dursun, H.",,10.1145/3593434.3593440,,,,"Enterprise software;  Open source software;  Open systems;  Software architecture;  Software reliability, Agile;  Compliance;  Devsecop;  Full-spec;  Full-stack;  Large groups;  Open-source;  Platform;  Security;  SRE, Large scale systems",cited By 0,Full spec software via platform engineering,ACM International Conference Proceeding Series,2023,EASE,conf
"Context: Serverless computing allows developers to create and deploy applications without the need to manage any underlying infrastructure, making it a more efficient and effective way to bring products to market. Serverless technology is gaining widespread adoption among many companies, becoming increasingly popular. However, the adoption of serverless technology brings with it several new challenges. Objective: To this end, we plan to gain a deep understanding of challenges and strategies, architectural issues and their causes, architectural patterns, antipatterns, migration towards serverless architecture, and state-of-the-art practices for vendor lock-in problems. Methodology: The research objective will be met through the use of an industrial empirical approach, including interviews, a case study, and a questionnaire survey. Possible outcomes: The expected outcomes would be (i) a multivocal literature review on design areas of serverless architecture (ii) an evidence-based framework for synthesizing serverless architectural challenges/solutions (iii) a decision-making process for migrating to serverless architecture (iv) a decision-making framework for selecting vendor platform. © 2023 Owner/Author.",Decision Model;  Empirical Investigation;  Serverless Architecture,"Hamza, M.",,10.1145/3593434.3593471,,,,"Industrial research;  Software architecture, Anti-patterns;  Architectural pattern;  Art practice;  Decision modeling;  Empirical investigation;  Lock-in;  Serverless architecture;  Serverless systems;  Software architecture design;  State of the art, Decision making",cited By 0,Software Architecture Design of a Serverless System,ACM International Conference Proceeding Series,2023,EASE,conf
"As a part of a research project concerning software maintainability assessment in collaboration with the development team, we wanted to explore dissensions between developers and the confounding effect of size. To this end, this study replicated and extended a recent study from Schnappinger et al. with the public part of its dataset and the metrics extracted from the graph-based tool Javanalyser. The entire processing pipeline was automated, from metrics extraction to the training of machine learning models. The study was extended by predicting the continuous maintainability to take account of dissensions. Then, all experimental shots were duplicated to evaluate the overall influence of the class size. In the end, the original study was successfully replicated. Moreover, good performance was achieved on the continuous maintainability prediction. Finally, the class size was not sufficient for fine-grained maintainability prediction. This study shows the necessity to explore the nature of what is measured by code metrics, and is also the first step in the construction of a maintainability model. © 2023 Owner/Author.",Expert Judgment;  Machine Learning;  Maintainability Prediction;  Ordinal Classification;  Software Maintainability,"Bertrand, S. and Ciappelloni, S. and Favier, P.-A. and Andre, J.-M.",,10.1145/3593434.3593488,,,,"Graphic methods;  Machine learning;  Maintainability, Class size;  Development teams;  Expert judgment;  Human levels;  Machine-learning;  Maintainability prediction;  Ordinal classification;  Prediction-based;  Software maintainability;  Static code metrics, Forecasting",cited By 0,Replication and Extension of Schnappinger's Study on Human-level Ordinal Maintainability Prediction Based on Static Code Metrics,ACM International Conference Proceeding Series,2023,EASE,conf
"Popular modern code review tools (e.g., Gerrit and GitHub) sort files in a code review in alphabetical order. A prior study (on open-source projects) shows that the changed files' positions in the code review affect the review process. Their results show that files placed lower in the order have less chance of receiving reviewing efforts than the other files. Hence, there is a higher chance of missing defects in these files. This paper explores the impact of file order in the code review of the well-known industrial project IntelliJ IDEA. First, we verify the results of the prior study on a big proprietary software project. Then, we explore an alternative to the default Alphabetical order: ordering changed files according to their code diff. Our results confirm the observations of the previous study. We discover that reviewers leave more comments on the files shown higher in the code review. Moreover, these results show that, even with the data skewed toward Alphabetical order, ordering changed files according to their code diff performs better than standard Alphabetical order regarding placing problematic files, which needs more reviewing effort, in the code review. These results confirm that exploring various ordering strategies for code review needs more exploration. © 2023 ACM.",Code Review;  Cognitive Bias;  Ranking Metrics,"Bagirov, F. and Derakhshanfar, P. and Kalina, A. and Kartysheva, E. and Kovalenko, V.",,10.1145/3593434.3593462,,,,"Codes (symbols);  Open systems, Code review;  Cognitive bias;  Industrial programs;  Open source projects;  Ordering strategy;  Proprietary software;  Ranking metric;  Review process;  Software project, Open source software",cited By 0,Assessing the Impact of File Ordering Strategies on Code Review Process,ACM International Conference Proceeding Series,2023,EASE,conf
"Programming languages often demarcate the internal sandbox, consisting of entities such as objects and variables, from the outside world, e.g., files or network. Although communication with the external world poses fundamental challenges for live programming, reversible debugging, testing, and program analysis in general, studies about this phenomenon are rare. In this paper, we present a preliminary empirical study about the prevalence of input/output (I/O) method usage in Java. We manually categorized 1435 native methods in a Java Standard Edition distribution into non-I/O and I/O-related methods, which were further classified into areas such as desktop or file-related ones. According to the static analysis of a call graph for 798 projects, about 57% of methods potentially call I/O natives. The results of dynamic analysis on 16 benchmarks showed that 21% of the executed methods directly or indirectly called an I/O native. We conclude that neglecting I/O is not a viable option for tool designers and suggest the integration of I/O-related metadata with source code to facilitate their querying. © 2023 ACM.",dynamic analysis;  empirical study;  input/output (I/O);  Java;  native methods;  static analysis,"Sulír, M. and Chodarev, S. and Nosáľ, M.",,10.1145/3593434.3593501,,Slovakia,This work was supported by project VEGA No. 1/0630/22 Lowering Programmers’ Cognitive Load Using Context-Dependent Dialogs.,"Java programming language;  Program debugging;  Software testing, Dynamics analysis;  Empirical studies;  Input-output;  Input-output methods;  Input/output;  Java;  Native method;  OR-networks;  Program analysis;  Testing analysis, Static analysis",cited By 0,Outside the Sandbox: A Study of Input/Output Methods in Java,ACM International Conference Proceeding Series,2023,EASE,conf
"Social inclusion is a fundamental feature of thriving societies. This paper first investigates barriers for social inclusion in online Software Engineering (SE) communities, by identifying a set of 11 attributes and organising them as a taxonomy. Second, by applying the taxonomy and analysing language used in the comments posted by members in 189 Gitter projects (with > 3 million comments), it presents the evidence for the social exclusion problem. It employs a keyword-based search approach for this purpose. Third, it presents a framework for improving social inclusion in SE communities. © 2023 ACM.",exclusion;  Social inclusion;  software engineering communities,"Savarimuthu, B.T.R. and Zareen, Z. and Cheriyan, J. and Yasir, M. and Galster, M.",,10.1145/3593434.3593463,,,,"Software engineering, Engineering community;  Exclusion;  Exclusion problem;  Fundamental features;  Keyword-based search;  Offensive languages;  On-line softwares;  Social exclusion;  Social inclusion;  Software engineering community, Taxonomies",cited By 0,Barriers for Social Inclusion in Online Software Engineering Communities - A Study of Offensive Language Use in Gitter Projects,ACM International Conference Proceeding Series,2023,EASE,conf
"During the last few years, Continuous Integration (CI) has become a common practice in open-source and industrial environments to reduce the scope for errors and increase the speed to market through the automated build and test processes. However, despite this wide adoption throughout the years, little is known about the challenges developers discuss. Analyzing the discussions of developers is required to understand what researchers, educators and practitioners should focus on, and how discussion communities can be helpful to shed the light on CI challenges. In this study, we examine Stack Overflow (SO), the most popular crowd-sourced forum, to understand the challenges developers face in the CI context. We collect a corpus of 27,728 CI-related developers posts from SO and analyze those posts through a mixed method with quantitative and qualitative analyzes. To study the trends of CI discussions, we investigated the metadata of CI questions, users and tags. Then, we extract the CI main topics using Latent Dirichlet Allocation (LDA) tuned with Genetic Algorithm (GA). Finally, we investigate the most popular and difficult topics faced by developers based on unanswered questions to get further insights into CI challenges. The LDA clustering reveals that developers face challenges with six main topics namely Build, Testing, Version Control, Configuration, Deployment, and CI Culture. Particularly, we found that the build topic is the most popular among the studied topics and that version control and testing topics are the most difficult for the SO community. Our study uncovers insights about CI challenges and adds evidence to existing knowledge about CI issues related especially to software build. © 2023 ACM.",,"Ouni, A. and Saidani, I. and Alomar, E. and Mkaouer, M.W.",,10.1145/3593434.3593485,,,,"Information management;  Open source software;  Statistics, Continuous integrations;  Empirical studies;  Industrial environments;  Latent Dirichlet allocation;  Mixed method;  Open-source;  Speed-to-market;  Stack overflow;  Test process;  Version control, Genetic algorithms",cited By 1,"An Empirical Study on Continuous Integration Trends, Topics and Challenges in Stack Overflow",ACM International Conference Proceeding Series,2023,EASE,conf
"Carefully selecting the right collection datastructure can significantly improve the performance of a Java program. Unfortunately, the performance impact of a certain collection selection can be hard to estimate. To assist developers, there exist tools that recommend collections to use based on static and/or dynamic information about a program. The majority of existing collection selection tools for Java pick their selections dynamically, which means that they must trade off sophistication in their selection algorithm against its run time overhead. For static collection selection, the Brainy tool has demonstrated that complex, machine-dependent models can produce substantial performance improvements, albeit only for C++ so far. In this paper, we port Brainy from C++ to Java, and evaluate its effectiveness for 5 benchmarks from the DaCapo benchmark suite. We compare it against the original program, but also to a ground truth, which we estimate using a variant of a brute-force approach to collection selection. Our results show that in four benchmarks out of five, our ground truth and the original program are similar. In one case, the ground truth shows an optimization yielding 20% speedup was available, but our port did not find this substantial optimization. We find that the port is more efficient but less effective than the ground truth, can easily adapt to new hardware architectures, and incorporate new datastructures with at most a few hours of human effort. We detail challenges that we encountered porting the Brainy approach to Java, and list a number of insights and directions for future research. © 2023 Owner/Author.",,"Couderc, N. and Reichenbach, C. and Soderberg, E.",,10.1145/3593434.3593469,,,"This work was funded by Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by the Knut and Alice Wallenberg Foundation.","C++ (programming language);  Computer software;  Java programming language, Dynamic information;  Ground truth;  Java program;  Optimisations;  Performance;  Performance impact;  Runtimes;  Selection algorithm;  Static dynamics;  Trade off, Economic and social effects",cited By 0,Classification-based Static Collection Selection for Java: Effectiveness and Adaptability,ACM International Conference Proceeding Series,2023,EASE,conf
"The fast distribution and deployment of security patches are important to protect users against cyberattacks. These fixes can be detected automatically by patch management triage systems. However, previous work has shown that automating the task is not easy, in some cases, because of poor documentation or lack of information in security fixes. For many years, standard practices in the security community have steered engineers to provide cryptic commit messages (i.e., patch software vulnerabilities silently) to avoid potential attacks and reputation damage. However, not providing enough documentation on vulnerability fixes can hinder trust between vendors and users. Current efforts in the security community aim to increase the level of transparency during patch and disclosing times to help build trust in the development community and make patch management processes faster. In this paper, we evaluate how informative security commit messages (i.e., messages attached to security fixes) are and how different levels of information can affect different tasks in automated patch triage systems. We observed that security engineers, in general, do not provide enough detail to enable the three automated triage systems at the same time. In addition, results show that security commit messages need to be more informative - 56.7% of the messages analyzed were documented poorly. Best practices to write informative and well-structured security commit messages (such as SECOM) should become a standard practice in the security community. © 2023 Owner/Author.",Best Practices;  Commit Messages;  Convention;  Patch Management Process;  Security,"Reis, S. and Abreu, R. and Pasareanu, C.",,10.1145/3593434.3593481,,,,"Best practices;  Commit message;  Convention;  Management process;  Patch management;  Patch management process;  Security;  Security community;  Security fix;  Standard practices, Cybersecurity",cited By 0,Are security commit messages informative? Not enough!,ACM International Conference Proceeding Series,2023,EASE,conf